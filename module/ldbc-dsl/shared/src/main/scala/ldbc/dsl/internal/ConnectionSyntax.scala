/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl.internal

import cats.Applicative
import cats.implicits.*
import cats.data.Kleisli
import cats.effect.Sync

import ldbc.sql.*
import ldbc.dsl.PreparedStatement

trait ConnectionSyntax extends StatementSyntax, SavepointSyntax:

  implicit class ConnectionF(connectionObject: Connection.type):

    def apply[F[_]: Sync](connection: java.sql.Connection): Connection[F] = new Connection[F]:

      override def createStatement(): F[Statement[F]] =
        Sync[F].blocking(connection.createStatement()).map(Statement[F])

      override def prepareStatement(sql: String): F[PreparedStatement[F]] =
        Sync[F].blocking(connection.prepareStatement(sql)).map(PreparedStatement[F])

      override def prepareCall(sql: String): F[CallableStatement[F]] =
        Sync[F].blocking(connection.prepareCall(sql)).map(CallableStatement[F])

      override def nativeSQL(sql: String): F[String] = Sync[F].blocking(connection.nativeSQL(sql))

      override def setAutoCommit(autoCommit: Boolean): F[Unit] = Sync[F].blocking(connection.setAutoCommit(autoCommit))

      override def getAutoCommit(): F[Boolean] = Sync[F].blocking(connection.getAutoCommit)

      override def commit(): F[Unit] = Sync[F].blocking(connection.commit())

      override def rollback(): F[Unit] = Sync[F].blocking(connection.rollback())

      override def close(): F[Unit] = Sync[F].blocking(connection.close())

      override def isClosed(): F[Boolean] = Sync[F].blocking(connection.isClosed)

      override def getMetaData(): F[DatabaseMetaData[F]] =
        Sync[F].blocking(connection.getMetaData).map(DatabaseMetaData[F])

      override def setReadOnly(readOnly: Boolean): F[Unit] = Sync[F].blocking(connection.setReadOnly(readOnly))

      override def isReadOnly: F[Boolean] = Sync[F].blocking(connection.isReadOnly)

      override def setCatalog(catalog: String): F[Unit] = Sync[F].blocking(connection.setCatalog(catalog))

      override def getCatalog(): F[String] = Sync[F].blocking(connection.getCatalog)

      override def setTransactionIsolation(level: Int): F[Unit] =
        Sync[F].blocking(connection.setTransactionIsolation(level))

      override def getTransactionIsolation(): F[Int] = Sync[F].blocking(connection.getTransactionIsolation)

      override def createStatement(
        resultSetType:        Int,
        resultSetConcurrency: Int
      ): F[Statement[F]] =
        Sync[F].blocking(connection.createStatement(resultSetType, resultSetConcurrency)).map(Statement[F])

      override def prepareStatement(
        sql:                  String,
        resultSetType:        Int,
        resultSetConcurrency: Int
      ): F[PreparedStatement[F]] =
        Sync[F]
          .blocking(connection.prepareStatement(sql, resultSetType, resultSetConcurrency))
          .map(PreparedStatement[F])

      override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[CallableStatement[F]] =
        Sync[F].blocking(connection.prepareCall(sql, resultSetType, resultSetConcurrency)).map(CallableStatement[F])

      override def prepareStatement(sql: String, autoGeneratedKeys: Int): F[PreparedStatement[F]] =
        Sync[F].blocking(connection.prepareStatement(sql, autoGeneratedKeys)).map(PreparedStatement[F])

      override def isValid(timeout: Int): F[Boolean] = Sync[F].blocking(connection.isValid(timeout))

      override def setSchema(schema: String): F[Unit] = Sync[F].blocking(connection.setSchema(schema))

      override def getSchema(): F[String] = Sync[F].blocking(connection.getSchema)

      override def setSavepoint(): F[Savepoint] = Sync[F].blocking(connection.setSavepoint()).map(Savepoint.apply)

      override def setSavepoint(name: String): F[Savepoint] =
        Sync[F].blocking(connection.setSavepoint(name)).map(Savepoint.apply)

      override def rollback(savepoint: Savepoint): F[Unit] =
        Sync[F].blocking(connection.rollback(MysqlSavepoint(savepoint.getSavepointName())))

      override def releaseSavepoint(savepoint: Savepoint): F[Unit] =
        Sync[F].blocking(connection.releaseSavepoint(MysqlSavepoint(savepoint.getSavepointName())))

    def pure[F[_]: Applicative, T](value: T): Kleisli[F, Connection[F], T] =
      Kleisli.pure[F, Connection[F], T](value)
