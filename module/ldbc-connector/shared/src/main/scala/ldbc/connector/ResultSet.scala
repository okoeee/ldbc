/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector

import java.time.*

import cats.*
import cats.syntax.all.*

import cats.effect.Ref

import ldbc.connector.util.Version
import ldbc.connector.exception.SQLException
import ldbc.connector.net.packet.response.*
import ldbc.connector.codec.all.*
import ldbc.connector.codec.Codec

/**
 * A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
 */
trait ResultSet[F[_]]:

  /**
   * Moves the cursor forward one row from its current position.
   * A <code>ResultSet</code> cursor is initially positioned
   * before the first row; the first call to the method
   * <code>next</code> makes the first row the current row; the
   * second call makes the second row the current row, and so on.
   * <p>
   * When a call to the <code>next</code> method returns <code>false</code>,
   * the cursor is positioned after the last row. Any
   * invocation of a <code>ResultSet</code> method which requires a
   * current row will result in a <code>SQLException</code> being thrown.
   *  If the result set type is <code>TYPE_FORWARD_ONLY</code>, it is vendor specified
   * whether their JDBC driver implementation will return <code>false</code> or
   *  throw an <code>SQLException</code> on a
   * subsequent call to <code>next</code>.
   *
   * <P>If an input stream is open for the current row, a call
   * to the method <code>next</code> will
   * implicitly close it. A <code>ResultSet</code> object's
   * warning chain is cleared when a new row is read.
   *
   * @return <code>true</code> if the new current row is valid;
   * <code>false</code> if there are no more rows
   */
  def next(): F[Boolean]

  /**
   * Releases this <code>ResultSet</code> object's database and
   * LDBC resources immediately instead of waiting for
   * this to happen when it is automatically closed.
   *
   * <P>The closing of a <code>ResultSet</code> object does <strong>not</strong> close the <code>Blob</code>,
   * <code>Clob</code> or <code>NClob</code> objects created by the <code>ResultSet</code>. <code>Blob</code>,
   * <code>Clob</code> or <code>NClob</code> objects remain valid for at least the duration of the
   * transaction in which they are created, unless their <code>free</code> method is invoked.
   *<p>
   * When a <code>ResultSet</code> is closed, any <code>ResultSetMetaData</code>
   * instances that were created by calling the  <code>getMetaData</code>
   * method remain accessible.
   *
   * <P><B>Note:</B> A <code>ResultSet</code> object
   * is automatically closed by the
   * <code>Statement</code> object that generated it when
   * that <code>Statement</code> object is closed,
   * re-executed, or is used to retrieve the next result from a
   * sequence of multiple results.
   *<p>
   * Calling the method <code>close</code> on a <code>ResultSet</code>
   * object that is already closed is a no-op.
   */
  def close(): F[Unit]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>String</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getString(columnIndex: Int): F[Option[String]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Boolean</code> in the Scala programming language.
   *
   * <P>If the designated column has a datatype of CHAR or VARCHAR
   * and contains a "0" or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT
   * and contains  a 0, a value of <code>false</code> is returned.  If the designated column has a datatype
   * of CHAR or VARCHAR
   * and contains a "1" or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT
   * and contains  a 1, a value of <code>true</code> is returned.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>false</code>
   */
  def getBoolean(columnIndex: Int): F[Boolean]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Byte</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getByte(columnIndex: Int): F[Byte]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Short</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getShort(columnIndex: Int): F[Short]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * an <code>Int</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getInt(columnIndex: Int): F[Int]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Long</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getLong(columnIndex: Int): F[Long]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Float</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getFloat(columnIndex: Int): F[Float]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Double</code> in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getDouble(columnIndex: Int): F[Double]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Byte</code> array in the Scala programming language.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getBytes(columnIndex: Int): F[Option[Array[Byte]]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalDate</code> object in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getDate(columnIndex: Int): F[Option[LocalDate]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalTime</code> object in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getTime(columnIndex: Int): F[Option[LocalTime]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalDateTime</code> object in the Scala programming language.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getTimestamp(columnIndex: Int): F[Option[LocalDateTime]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>String</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getString(columnLabel: String): F[Option[String]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Boolean</code> in the Scala programming language.
   *
   * <P>If the designated column has a datatype of CHAR or VARCHAR
   * and contains a "0" or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT
   * and contains  a 0, a value of <code>false</code> is returned.  If the designated column has a datatype
   * of CHAR or VARCHAR
   * and contains a "1" or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT
   * and contains  a 1, a value of <code>true</code> is returned.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>false</code>
   */
  def getBoolean(columnLabel: String): F[Boolean]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Byte</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getByte(columnLabel: String): F[Byte]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Short</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getShort(columnLabel: String): F[Short]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * an <code>Int</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getInt(columnLabel: String): F[Int]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Long</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getLong(columnLabel: String): F[Long]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Float</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getFloat(columnLabel: String): F[Float]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>Double</code> in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>0</code>
   */
  def getDouble(columnLabel: String): F[Double]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>byte</code> array in the Scala programming language.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getBytes(columnLabel: String): F[Option[Array[Byte]]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalDate</code> object in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getDate(columnLabel: String): F[Option[LocalDate]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalTime</code> object in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value;
   * if the value is SQL <code>NULL</code>,
   * the value returned is <code>None</code>
   */
  def getTime(columnLabel: String): F[Option[LocalTime]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as
   * a <code>java.time.LocalDateTime</code> object in the Scala programming language.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value; if the value is SQL <code>NULL</code>, the
   * value returned is <code>None</code>
   */
  def getTimestamp(columnLabel: String): F[Option[LocalDateTime]]

  /**
   * Retrieves the  number, types and properties of
   * this <code>ResultSet</code> object's columns.
   *
   * @return the description of this <code>ResultSet</code> object's columns
   */
  def getMetaData(): F[ResultSetMetaData]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as a
   * <code>scala.math.BigDecimal</code> with full precision.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value (full precision);
   * if the value is SQL <code>NULL</code>, the value returned is
   * <code>None</code> in the Scala programming language.
   */
  def getBigDecimal(columnIndex: Int): F[Option[BigDecimal]]

  /**
   * Retrieves the value of the designated column in the current row
   * of this <code>ResultSet</code> object as a
   * <code>scala.math.BigDecimal</code> with full precision.
   *
   * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
   * @return the column value (full precision);
   * if the value is SQL <code>NULL</code>, the value returned is
   * <code>None</code> in the Scala programming language.
   */
  def getBigDecimal(columnLabel: String): F[Option[BigDecimal]]

  /**
   * Retrieves whether the cursor is before the first row in
   * this <code>ResultSet</code> object.
   * <p>
   * <strong>Note:</strong>Support for the <code>isBeforeFirst</code> method
   * is optional for <code>ResultSet</code>s with a result
   * set type of <code>TYPE_FORWARD_ONLY</code>
   *
   * @return <code>true</code> if the cursor is before the first row;
   * <code>false</code> if the cursor is at any other position or the
   * result set contains no rows
   */
  def isBeforeFirst(): F[Boolean]

  /**
   * Retrieves whether the cursor is on the first row of
   * this <code>ResultSet</code> object.
   * <p>
   * <strong>Note:</strong>Support for the <code>isFirst</code> method
   * is optional for <code>ResultSet</code>s with a result
   * set type of <code>TYPE_FORWARD_ONLY</code>
   *
   * @return <code>true</code> if the cursor is on the first row;
   * <code>false</code> otherwise
   */
  def isFirst(): F[Boolean]

  /**
   * Retrieves whether the cursor is after the last row in
   * this <code>ResultSet</code> object.
   * <p>
   * <strong>Note:</strong>Support for the <code>isAfterLast</code> method
   * is optional for <code>ResultSet</code>s with a result
   * set type of <code>TYPE_FORWARD_ONLY</code>
   *
   * @return <code>true</code> if the cursor is after the last row;
   * <code>false</code> if the cursor is at any other position or the
   * result set contains no rows
   */
  def isAfterLast(): F[Boolean]

  /**
   * Retrieves whether the cursor is on the last row of
   * this <code>ResultSet</code> object.
   *  <strong>Note:</strong> Calling the method <code>isLast</code> may be expensive
   * because the LDBC
   * might need to fetch ahead one row in order to determine
   * whether the current row is the last row in the result set.
   * <p>
   * <strong>Note:</strong> Support for the <code>isLast</code> method
   * is optional for <code>ResultSet</code>s with a result
   * set type of <code>TYPE_FORWARD_ONLY</code>
   * @return <code>true</code> if the cursor is on the last row;
   * <code>false</code> otherwise
   */
  def isLast(): F[Boolean]

  /**
   * Moves the cursor to the front of
   * this <code>ResultSet</code> object, just before the
   * first row. This method has no effect if the result set contains no rows.
   */
  def beforeFirst(): F[Unit]

  /**
   * Moves the cursor to the end of
   * this <code>ResultSet</code> object, just after the
   * last row. This method has no effect if the result set contains no rows.
   */
  def afterLast(): F[Unit]

  /**
   * Moves the cursor to the first row in
   * this <code>ResultSet</code> object.
   *
   * @return <code>true</code> if the cursor is on a valid row;
   * <code>false</code> if there are no rows in the result set
   */
  def first(): F[Boolean]

  /**
   * Moves the cursor to the last row in
   * this <code>ResultSet</code> object.
   *
   * @return <code>true</code> if the cursor is on a valid row;
   * <code>false</code> if there are no rows in the result set
   */
  def last(): F[Boolean]

  /**
   * Retrieves the current row number.  The first row is number 1, the
   * second number 2, and so on.
   * <p>
   * <strong>Note:</strong>Support for the <code>getRow</code> method
   * is optional for <code>ResultSet</code>s with a result
   * set type of <code>TYPE_FORWARD_ONLY</code>
   *
   * @return the current row number; <code>0</code> if there is no current row
   */
  def getRow(): F[Int]

  /**
   * Moves the cursor to the given row number in
   * this <code>ResultSet</code> object.
   *
   * <p>If the row number is positive, the cursor moves to
   * the given row number with respect to the
   * beginning of the result set.  The first row is row 1, the second
   * is row 2, and so on.
   *
   * <p>If the given row number is negative, the cursor moves to
   * an absolute row position with respect to
   * the end of the result set.  For example, calling the method
   * <code>absolute(-1)</code> positions the
   * cursor on the last row; calling the method <code>absolute(-2)</code>
   * moves the cursor to the next-to-last row, and so on.
   *
   * <p>If the row number specified is zero, the cursor is moved to
   * before the first row.
   *
   * <p>An attempt to position the cursor beyond the first/last row in
   * the result set leaves the cursor before the first row or after
   * the last row.
   *
   * <p><B>Note:</B> Calling <code>absolute(1)</code> is the same
   * as calling <code>first()</code>. Calling <code>absolute(-1)</code>
   * is the same as calling <code>last()</code>.
   *
   * @param row the number of the row to which the cursor should move.
   *        A value of zero indicates that the cursor will be positioned
   *        before the first row; a positive number indicates the row number
   *        counting from the beginning of the result set; a negative number
   *        indicates the row number counting from the end of the result set
   * @return <code>true</code> if the cursor is moved to a position in this
   */
  def absolute(row: Int): F[Boolean]

  /**
   * Moves the cursor a relative number of rows, either positive or negative.
   * Attempting to move beyond the first/last row in the
   * result set positions the cursor before/after the
   * the first/last row. Calling <code>relative(0)</code> is valid, but does
   * not change the cursor position.
   *
   * <p>Note: Calling the method <code>relative(1)</code>
   * is identical to calling the method <code>next()</code> and
   * calling the method <code>relative(-1)</code> is identical
   * to calling the method <code>previous()</code>.
   *
   * @param rows an <code>int</code> specifying the number of rows to
   *        move from the current row; a positive number moves the cursor
   *        forward; a negative number moves the cursor backward
   * @return <code>true</code> if the cursor is on a row;
   *         <code>false</code> otherwise
   */
  def relative(rows: Int): F[Boolean]

  /**
   * Moves the cursor to the previous row in this
   * <code>ResultSet</code> object.
   *<p>
   * When a call to the <code>previous</code> method returns <code>false</code>,
   * the cursor is positioned before the first row.  Any invocation of a
   * <code>ResultSet</code> method which requires a current row will result in a
   * <code>SQLException</code> being thrown.
   *<p>
   *
   * @return <code>true</code> if the cursor is now positioned on a valid row;
   * <code>false</code> if the cursor is positioned before the first row
   */
  def previous(): F[Boolean]

  /**
   * Retrieves the type of this <code>ResultSet</code> object.
   * The type is determined by the <code>Statement</code> object
   * that created the result set.
   *
   * @return <code>ResultSet.TYPE_FORWARD_ONLY</code>,
   *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>,
   *         or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
   */
  def getType(): F[Int]

  /**
   * Retrieves the concurrency mode of this <code>ResultSet</code> object.
   * The concurrency used is determined by the
   * <code>Statement</code> object that created the result set.
   *
   * @return the concurrency type, either
   *         <code>ResultSet.CONCUR_READ_ONLY</code>
   *         or <code>ResultSet.CONCUR_UPDATABLE</code>
   */
  def getConcurrency(): F[Int]

  /**
   * Function to decode all lines with the specified type.
   *
   * @param codec
   *   The codec to decode the value
   * @tparam T
   *   The type of the value
   * @return
   *   A list of values decoded with the specified type.
   */
  def decode[T](codec: Codec[T]): F[List[T]]

object ResultSet:

  /**
   * The constant indicating the type for a <code>ResultSet</code> object
   * whose cursor may move only forward.
   */
  val TYPE_FORWARD_ONLY: Int = 1003

  /**
   * The constant indicating the type for a <code>ResultSet</code> object
   * that is scrollable but generally not sensitive to changes to the data
   * that underlies the <code>ResultSet</code>.
   */
  val TYPE_SCROLL_INSENSITIVE: Int = 1004

  /**
   * The constant indicating the type for a <code>ResultSet</code> object
   * that is scrollable and generally sensitive to changes to the data
   * that underlies the <code>ResultSet</code>.
   */
  val TYPE_SCROLL_SENSITIVE: Int = 1005

  /**
   * The constant indicating the concurrency mode for a
   * <code>ResultSet</code> object that may NOT be updated.
   */
  val CONCUR_READ_ONLY: Int = 1007

  /**
   * The constant indicating the concurrency mode for a
   * <code>ResultSet</code> object that may be updated.
   */
  val CONCUR_UPDATABLE: Int = 1008

  /**
   * The constant indicating that open <code>ResultSet</code> objects with this
   * holdability will remain open when the current transaction is committed.
   */
  val HOLD_CURSORS_OVER_COMMIT: Int = 1

  /**
   * The constant indicating that open <code>ResultSet</code> objects with this
   * holdability will be closed when the current transaction is committed.
   */
  val CLOSE_CURSORS_AT_COMMIT: Int = 2

  private[ldbc] case class Impl[F[_]](
    columns:              Vector[ColumnDefinitionPacket],
    records:              Vector[ResultSetRowPacket],
    serverVariables:      Map[String, String],
    version:              Version,
    isClosed:             Ref[F, Boolean],
    currentCursor:        Ref[F, Int],
    currentRow:           Ref[F, Option[ResultSetRowPacket]],
    resultSetType:        Int = TYPE_FORWARD_ONLY,
    resultSetConcurrency: Int = ResultSet.CONCUR_READ_ONLY
  )(using ev: MonadError[F, Throwable])
    extends ResultSet[F]:

    def next(): F[Boolean] =
      checkClose {
        currentCursor.get.flatMap { cursor =>
          if cursor <= records.size then
            currentRow.set(records.lift(cursor)) *>
              currentCursor.update(_ + 1) *>
              currentRow.get.map(_.isDefined)
          else currentCursor.update(_ + 1).as(false)
        }
      }

    override def close(): F[Unit] = isClosed.set(true)

    override def getString(columnIndex: Int): F[Option[String]] =
      checkClose {
        rowDecode(row => text.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getBoolean(columnIndex: Int): F[Boolean] =
      checkClose {
        rowDecode(row => boolean.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(false))
      }

    override def getByte(columnIndex: Int): F[Byte] =
      checkClose {
        rowDecode(row => tinyint.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0))
      }

    override def getShort(columnIndex: Int): F[Short] =
      checkClose {
        rowDecode(row => smallint.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0))
      }

    override def getInt(columnIndex: Int): F[Int] =
      checkClose {
        rowDecode(row => int.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0))
      }

    override def getLong(columnIndex: Int): F[Long] =
      checkClose {
        rowDecode(row => bigint.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0L))
      }

    override def getFloat(columnIndex: Int): F[Float] =
      checkClose {
        rowDecode(row => float.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0f))
      }

    override def getDouble(columnIndex: Int): F[Double] =
      checkClose {
        rowDecode(row => double.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
          .map(_.getOrElse(0.toDouble))
      }

    override def getBytes(columnIndex: Int): F[Option[Array[Byte]]] =
      checkClose {
        rowDecode(row => binary(255).decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getDate(columnIndex: Int): F[Option[LocalDate]] =
      checkClose {
        rowDecode(row => date.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getTime(columnIndex: Int): F[Option[LocalTime]] =
      checkClose {
        rowDecode(row => time.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getTimestamp(columnIndex: Int): F[Option[LocalDateTime]] =
      checkClose {
        rowDecode(row => timestamp.decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getString(columnLabel: String): F[Option[String]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getString(index + 1)
          case None             => ev.pure(None)
      }

    override def getBoolean(columnLabel: String): F[Boolean] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getBoolean(index + 1)
          case None             => ev.pure(false)
      }

    override def getByte(columnLabel: String): F[Byte] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getByte(index + 1)
          case None             => ev.pure(0)
      }

    override def getShort(columnLabel: String): F[Short] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getShort(index + 1)
          case None             => ev.pure(0)
      }

    override def getInt(columnLabel: String): F[Int] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getInt(index + 1)
          case None             => ev.pure(0)
      }

    override def getLong(columnLabel: String): F[Long] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getLong(index + 1)
          case None             => ev.pure(0L)
      }

    override def getFloat(columnLabel: String): F[Float] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getFloat(index + 1)
          case None             => ev.pure(0f)
      }

    override def getDouble(columnLabel: String): F[Double] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getDouble(index + 1)
          case None             => ev.pure(0.toDouble)
      }

    override def getBytes(columnLabel: String): F[Option[Array[Byte]]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getBytes(index + 1)
          case None             => ev.pure(None)
      }

    override def getDate(columnLabel: String): F[Option[LocalDate]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getDate(index + 1)
          case None             => ev.pure(None)
      }

    override def getTime(columnLabel: String): F[Option[LocalTime]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getTime(index + 1)
          case None             => ev.pure(None)
      }

    override def getTimestamp(columnLabel: String): F[Option[LocalDateTime]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getTimestamp(index + 1)
          case None             => ev.pure(None)
      }

    override def getMetaData(): F[ResultSetMetaData] =
      checkClose {
        ev.pure(ResultSetMetaData(columns, serverVariables, version))
      }

    override def getBigDecimal(columnIndex: Int): F[Option[BigDecimal]] =
      checkClose {
        rowDecode(row => decimal().decode(columnIndex, List(row.values(columnIndex - 1))).toOption)
      }

    override def getBigDecimal(columnLabel: String): F[Option[BigDecimal]] =
      checkClose {
        columns.zipWithIndex.find(_._1.name == columnLabel) match
          case Some((_, index)) => getBigDecimal(index + 1)
          case None             => ev.pure(None)
      }

    override def isBeforeFirst(): F[Boolean] =
      currentCursor.get.map { cursor =>
        cursor <= 0 && records.nonEmpty
      }

    override def isAfterLast(): F[Boolean] =
      currentCursor.get.map { cursor =>
        cursor > records.size && records.nonEmpty
      }

    override def isFirst(): F[Boolean] =
      currentCursor.get.map { cursor =>
        cursor > 0
      }

    override def isLast(): F[Boolean] =
      currentCursor.get.map { cursor =>
        cursor == records.size
      }

    override def beforeFirst(): F[Unit] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else currentCursor.set(0)

    override def afterLast(): F[Unit] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else currentCursor.set(records.size + 1)

    override def first(): F[Boolean] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else
        currentCursor.set(1) *>
          currentRow.set(records.headOption) *>
          currentRow.get.map(_.isDefined && records.nonEmpty)

    override def last(): F[Boolean] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else
        currentCursor.set(records.size) *>
          currentRow.set(records.lastOption) *>
          currentRow.get.map(_.isDefined && records.nonEmpty)

    override def getRow(): F[Int] =
      currentCursor.get.map { cursor =>
        if cursor > records.size then 0
        else cursor
      }

    override def absolute(row: Int): F[Boolean] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else if row > 0 then
        currentCursor.set(row) *>
          currentRow.set(records.lift(row - 1)).map(_ => row >= 1 && row <= records.size)
      else if row < 0 then
        val position = records.size + row + 1
        currentCursor.set(position) *>
          currentRow.set(records.lift(records.size + row)).map(_ => position >= 1 && position <= records.size)
      else
        currentCursor.set(0) *>
          currentRow.set(None).map(_ => false)

    override def relative(rows: Int): F[Boolean] =
      if resultSetType == TYPE_FORWARD_ONLY then
        raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
      else
        currentCursor.get.flatMap { cursor =>
          val position = cursor + rows
          if position >= 1 && position <= records.size then
            currentCursor.set(position) *>
              currentRow.set(records.lift(position - 1)).map(_ => true)
          else
            currentCursor.updateAndGet(_ => 0).flatMap { updated =>
              currentRow.set(records.lift(updated)).map(_ => false)
            }
        }

    override def previous(): F[Boolean] =
      currentCursor.get.flatMap { cursor =>
        if resultSetType == TYPE_FORWARD_ONLY then
          raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
        else if cursor > 0 then
          currentCursor.updateAndGet(_ - 1).flatMap { updated =>
            currentRow.updateAndGet(_ => records.lift(updated - 1)).map(_.isDefined)
          }
        else
          currentCursor.set(0) *>
            currentRow.set(None).map(_ => false)
      }

    override def getType(): F[Int] =
      checkClose {
        ev.pure(resultSetType)
      }

    override def getConcurrency(): F[Int] =
      checkClose {
        ev.pure(resultSetConcurrency)
      }

    override def decode[T](codec: Codec[T]): F[List[T]] =
      checkClose {
        ev.point(
          records.flatMap(row => codec.decode(0, row.values).toOption).toList
        )
      }

    private def checkClose[T](f: => F[T]): F[T] =
      isClosed.get.flatMap { isClosed =>
        if isClosed then raiseError("Operation not allowed after ResultSet closed")
        else f
      }

    private def rowDecode[T](decode: ResultSetRowPacket => Option[T]): F[Option[T]] =
      currentRow.get.map(_.flatMap(decode))

    private def raiseError[T](message: String): F[T] =
      ev.raiseError(new SQLException(message))

  def apply[F[_]](
    columns:       Vector[ColumnDefinitionPacket],
    records:       Vector[ResultSetRowPacket],
    serverVariables:      Map[String, String],
    version:       Version,
    isClosed:      Ref[F, Boolean],
    currentCursor: Ref[F, Int],
    currentRow:    Ref[F, Option[ResultSetRowPacket]]
  )(using MonadError[F, Throwable]): ResultSet[F] =
    Impl[F](columns, records, serverVariables, version, isClosed, currentCursor, currentRow, ResultSet.TYPE_FORWARD_ONLY)

  def apply[F[_]](
    columns:              Vector[ColumnDefinitionPacket],
    records:              Vector[ResultSetRowPacket],
    serverVariables:      Map[String, String],
    version:              Version,
    isClosed:             Ref[F, Boolean],
    currentCursor:        Ref[F, Int],
    currentRow:           Ref[F, Option[ResultSetRowPacket]],
    resultSetType:        Int,
    resultSetConcurrency: Int
  )(using MonadError[F, Throwable]): ResultSet[F] =
    Impl[F](columns, records, serverVariables, version, isClosed, currentCursor, currentRow, resultSetType, resultSetConcurrency)

  def empty[F[_]](
                   serverVariables:      Map[String, String],
    version:       Version,
    isClosed:      Ref[F, Boolean],
    currentCursor: Ref[F, Int],
    currentRow:    Ref[F, Option[ResultSetRowPacket]]
  )(using MonadError[F, Throwable]): ResultSet[F] =
    this.apply(
      Vector.empty,
      Vector.empty,
      serverVariables,
      version,
      isClosed,
      currentCursor,
      currentRow
    )
